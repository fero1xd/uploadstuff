{"version":3,"sources":["../src/useUploadStuff.ts","../../uploadstuff/client.ts","../src/utils/useEvent.ts","../src/utils/useFetch.ts"],"sourcesContent":["import { useState } from \"react\";\r\nimport type { FileRouter } from \"uploadstuff/server\";\r\nimport { DANGEROUS__uploadFiles } from \"uploadstuff/client\";\r\n\r\nimport { useEvent } from \"./utils/useEvent\";\r\nimport useFetch from \"./utils/useFetch\";\r\n\r\ntype EndpointMetadata = {\r\n  slug: string;\r\n  maxSize: string;\r\n  fileTypes: string[];\r\n}[];\r\nconst useEndpointMetadata = (endpoint: string) => {\r\n  const { data } = useFetch<EndpointMetadata>(\"/api/uploadstuff\");\r\n\r\n  // TODO: Log on errors in dev\r\n\r\n  return data?.find((x) => x.slug === endpoint);\r\n};\r\n\r\nexport const useUploadStuff = <T extends string>({\r\n  endpoint,\r\n  onClientUploadComplete,\r\n  onUploadError,\r\n}: {\r\n  endpoint: T;\r\n  onClientUploadComplete?: (\r\n    res?: Awaited<ReturnType<typeof DANGEROUS__uploadFiles>>\r\n  ) => void;\r\n  onUploadError?: (e: Error) => void;\r\n}) => {\r\n  const [isUploading, setUploading] = useState(false);\r\n\r\n  const permittedFileInfo = useEndpointMetadata(endpoint);\r\n\r\n  const startUpload = useEvent(async (files: File[]) => {\r\n    setUploading(true);\r\n    try {\r\n      const res = await DANGEROUS__uploadFiles(files, endpoint);\r\n      setUploading(false);\r\n      onClientUploadComplete?.(res);\r\n      return res;\r\n    } catch (e) {\r\n      setUploading(false);\r\n      onUploadError?.(e as Error);\r\n      return;\r\n    }\r\n  });\r\n  return {\r\n    startUpload,\r\n    isUploading,\r\n    permittedFileInfo,\r\n  } as const;\r\n};\r\n\r\nexport const generateReactHelpers = <TRouter extends FileRouter>() => {\r\n  type TRouterKey = keyof TRouter extends string ? keyof TRouter : string;\r\n\r\n  return {\r\n    useUploadStuff: useUploadStuff<TRouterKey>,\r\n    uploadFiles: DANGEROUS__uploadFiles<TRouterKey>,\r\n  } as const;\r\n};\r\n\r\nexport type FullFile = {\r\n  file: File;\r\n  contents: string;\r\n};\r\n","import type { FileRouter } from \"./server\";\r\n\r\nconst createRequestPermsUrl = (config: { url?: string; slug: string }) => {\r\n  const queryParams = `?actionType=upload&slug=${config.slug}`;\r\n\r\n  return `${config?.url ?? \"/api/uploadstuff\"}${queryParams}`;\r\n};\r\n\r\nexport const DANGEROUS__uploadFiles = async <T extends string>(\r\n  files: File[],\r\n  endpoint: T,\r\n  config?: {\r\n    url?: string;\r\n  }\r\n) => {\r\n  // Get presigned URL for S3 upload\r\n  const s3ConnectionRes = await fetch(\r\n    createRequestPermsUrl({ url: config?.url, slug: endpoint }),\r\n    {\r\n      method: \"POST\",\r\n      body: JSON.stringify({\r\n        files: files.map((f) => f.name),\r\n      }),\r\n    }\r\n  ).then((res) => {\r\n    // check for 200 response\r\n    if (!res.ok) throw new Error(\"Failed to get presigned URLs\");\r\n\r\n    // attempt to parse response\r\n    try {\r\n      return res.json();\r\n    } catch (e) {\r\n      // response is not JSON\r\n      console.error(e);\r\n      throw new Error(`Failed to parse response as JSON. Got: ${res.body}`);\r\n    }\r\n  });\r\n\r\n  if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes))\r\n    throw \"No url received. How did you get here?\";\r\n\r\n  const fileUploadPromises = s3ConnectionRes.map(async (presigned: any) => {\r\n    const file = files.find((f) => f.name === presigned.name);\r\n\r\n    if (!file) {\r\n      console.error(\"No file found for presigned URL\", presigned);\r\n      throw new Error(\"No file found for presigned URL\");\r\n    }\r\n    const { url } = presigned.presignedUrl;\r\n\r\n    // Do S3 upload\r\n    const upload = await fetch(url, {\r\n      method: \"PUT\",\r\n      body: file,\r\n      headers: {\r\n        \"Content-Type\": \"multipart/form-data\",\r\n      },\r\n    });\r\n\r\n    if (!upload.ok) throw new Error(\"Upload failed.\");\r\n\r\n    // Generate a URL for the uploaded image since AWS won't give me one\r\n    const dom = url.split(\"?\")[0].split(\"/\").slice(0, 4).join(\"/\");\r\n    const genUrl = dom + \"/\" + encodeURIComponent(presigned.key);\r\n\r\n    console.log(\"URL for uploaded image\", genUrl);\r\n\r\n    return {\r\n      fileKey: presigned.key,\r\n      fileUrl: genUrl,\r\n    };\r\n  });\r\n\r\n  return Promise.all(fileUploadPromises) as Promise<\r\n    { fileUrl: string; fileKey: string }[]\r\n  >;\r\n};\r\n\r\nexport type UploadFileType<T extends string> = typeof DANGEROUS__uploadFiles<T>;\r\n\r\nexport const genUploader = <\r\n  TRouter extends FileRouter\r\n>(): typeof DANGEROUS__uploadFiles<\r\n  keyof TRouter extends string ? keyof TRouter : string\r\n> => {\r\n  return DANGEROUS__uploadFiles;\r\n};\r\n\r\nexport const classNames = (...classes: string[]) => {\r\n  return classes.filter(Boolean).join(\" \");\r\n};\r\n\r\nexport const generateMimeTypes = (fileTypes: string[]) => {\r\n  return fileTypes.map((type) => `${type}/*`);\r\n};\r\n\r\nconst fromEntries = (iterable: any) => {\r\n  return [...iterable].reduce((obj, [key, val]) => {\r\n    obj[key] = val;\r\n    return obj;\r\n  }, {});\r\n};\r\n\r\nexport const generateClientDropzoneAccept = (fileTypes: string[]) => {\r\n  const mimeTypes = generateMimeTypes(fileTypes);\r\n  return fromEntries(mimeTypes.map((type) => [type, []]));\r\n};\r\n","// Ripped from https://github.com/scottrippey/react-use-event-hook\r\nimport React from \"react\";\r\n\r\ntype AnyFunction = (...args: any[]) => any;\r\n\r\n/**\r\n * Suppress the warning when using useLayoutEffect with SSR. (https://reactjs.org/link/uselayouteffect-ssr)\r\n * Make use of useInsertionEffect if available.\r\n */\r\nconst useInsertionEffect =\r\n  typeof window !== \"undefined\"\r\n    ? // useInsertionEffect is available in React 18+\r\n      React.useInsertionEffect || React.useLayoutEffect\r\n    : () => {};\r\n\r\n/**\r\n * Similar to useCallback, with a few subtle differences:\r\n * - The returned function is a stable reference, and will always be the same between renders\r\n * - No dependency lists required\r\n * - Properties or state accessed within the callback will always be \"current\"\r\n */\r\nexport function useEvent<TCallback extends AnyFunction>(\r\n  callback: TCallback\r\n): TCallback {\r\n  // Keep track of the latest callback:\r\n  const latestRef = React.useRef<TCallback>(\r\n    useEvent_shouldNotBeInvokedBeforeMount as any\r\n  );\r\n  useInsertionEffect(() => {\r\n    latestRef.current = callback;\r\n  }, [callback]);\r\n\r\n  // Create a stable callback that always calls the latest callback:\r\n  // using useRef instead of useCallback avoids creating and empty array on every render\r\n  const stableRef = React.useRef<TCallback>(null as any);\r\n  if (!stableRef.current) {\r\n    stableRef.current = function (this: any) {\r\n      return latestRef.current.apply(this, arguments as any);\r\n    } as TCallback;\r\n  }\r\n\r\n  return stableRef.current;\r\n}\r\n\r\n/**\r\n * Render methods should be pure, especially when concurrency is used,\r\n * so we will throw this error if the callback is called while rendering.\r\n */\r\nfunction useEvent_shouldNotBeInvokedBeforeMount() {\r\n  throw new Error(\r\n    \"INVALID_USEEVENT_INVOCATION: the callback from useEvent cannot be invoked before the component has mounted.\"\r\n  );\r\n}\r\n","// Ripped from https://usehooks-ts.com/react-hook/use-fetch\r\nimport { useEffect, useReducer, useRef } from \"react\";\r\n\r\ninterface State<T> {\r\n  data?: T;\r\n  error?: Error;\r\n}\r\n\r\ntype Cache<T> = { [url: string]: T };\r\n\r\n// discriminated union type\r\ntype Action<T> =\r\n  | { type: \"loading\" }\r\n  | { type: \"fetched\"; payload: T }\r\n  | { type: \"error\"; payload: Error };\r\n\r\nfunction useFetch<T = unknown>(url?: string, options?: RequestInit): State<T> {\r\n  const cache = useRef<Cache<T>>({});\r\n\r\n  // Used to prevent state update if the component is unmounted\r\n  const cancelRequest = useRef<boolean>(false);\r\n\r\n  const initialState: State<T> = {\r\n    error: undefined,\r\n    data: undefined,\r\n  };\r\n\r\n  // Keep state logic separated\r\n  const fetchReducer = (state: State<T>, action: Action<T>): State<T> => {\r\n    switch (action.type) {\r\n      case \"loading\":\r\n        return { ...initialState };\r\n      case \"fetched\":\r\n        return { ...initialState, data: action.payload };\r\n      case \"error\":\r\n        return { ...initialState, error: action.payload };\r\n      default:\r\n        return state;\r\n    }\r\n  };\r\n\r\n  const [state, dispatch] = useReducer(fetchReducer, initialState);\r\n\r\n  useEffect(() => {\r\n    // Do nothing if the url is not given\r\n    if (!url) return;\r\n\r\n    cancelRequest.current = false;\r\n\r\n    const fetchData = async () => {\r\n      dispatch({ type: \"loading\" });\r\n\r\n      // If a cache exists for this url, return it\r\n      if (cache.current[url]) {\r\n        dispatch({ type: \"fetched\", payload: cache.current[url] });\r\n        return;\r\n      }\r\n\r\n      try {\r\n        const response = await fetch(url, options);\r\n        if (!response.ok) {\r\n          throw new Error(response.statusText);\r\n        }\r\n\r\n        const data = (await response.json()) as T;\r\n        cache.current[url] = data;\r\n        if (cancelRequest.current) return;\r\n\r\n        dispatch({ type: \"fetched\", payload: data });\r\n      } catch (error) {\r\n        if (cancelRequest.current) return;\r\n\r\n        dispatch({ type: \"error\", payload: error as Error });\r\n      }\r\n    };\r\n\r\n    void fetchData();\r\n\r\n    // Use the cleanup function for avoiding a possibly...\r\n    // ...state update after the component was unmounted\r\n    return () => {\r\n      cancelRequest.current = true;\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [url]);\r\n\r\n  return state;\r\n}\r\n\r\nexport default useFetch;\r\n"],"mappings":"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","names":["state"]}